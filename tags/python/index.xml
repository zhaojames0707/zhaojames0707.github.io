<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Mission Namek</title>
    <link>http://zhaojames0707.github.io/tags/python/</link>
    <description>Recent content in Python on Mission Namek</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2016</copyright>
    <lastBuildDate>Wed, 29 Jun 2016 23:22:18 +0800</lastBuildDate>
    <atom:link href="http://zhaojames0707.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>解决 django 中 mysql gone away 的问题</title>
      <link>http://zhaojames0707.github.io/post/django_mysql_gone_away/</link>
      <pubDate>Wed, 29 Jun 2016 23:22:18 +0800</pubDate>
      
      <guid>http://zhaojames0707.github.io/post/django_mysql_gone_away/</guid>
      <description>

&lt;p&gt;最近在项目中，我使用 Django Command 模块写了一个脚本，处理从 MQ 发来的消息，并入库。在测试过程中，程序运行良好，但是在程序上线并运行一段时间后，出现了以下错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;OperationalError: (2006, &#39;MySQL server has gone away&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;发现问题:85fe840e32cb336e68094805b95543ea&#34;&gt;发现问题&lt;/h3&gt;

&lt;p&gt;经过一段时间的排查后，我发现了问题的原因：因为我要入库的消息并不频繁，所以我的程序的入库操作之间可能会间隔一段时间，而当这段时间大于 MySQL 配置的超时时间后，MySQL 便会主动断开与该程序的连接；此时，程序做数据库相关操作，则会发现数据库连接已经失效，因而报 &lt;code&gt;MySQL server has gone away&lt;/code&gt;的异常。&lt;/p&gt;

&lt;p&gt;查看 MySQL 配置的超时时间方法为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;show variables like &#39;wait_timeout&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;分析问题:85fe840e32cb336e68094805b95543ea&#34;&gt;分析问题&lt;/h3&gt;

&lt;p&gt;在网上搜索相关问题后，我发现有很多人问过相关问题，而 Django 官网的这个&lt;a href=&#34;https://code.djangoproject.com/ticket/21597#comment:29&#34;&gt;讨论&lt;/a&gt;，给了我很大帮助。&lt;/p&gt;

&lt;p&gt;处理方法有两个：&lt;/p&gt;

&lt;p&gt;1) 每次调用完 Model 后，手动关闭 connection&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from django.db import connection

connection.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2) 调整数据库的超时时间(不推荐！)&lt;/p&gt;

&lt;p&gt;但是，这两个都不适合我的程序：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;方法1是针对 Model 操作间隔一定很长的情况，如果某个时间段内需要很频繁的操作数据库，那么频繁关闭-新建数据库连接无疑是低效的。&lt;/li&gt;
&lt;li&gt;方法2直接修改数据库超时时间，很容易影响别的服务，会带来很多潜在的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对我的情况，我参考了 Django 源码涉及数据库连接维护的部分。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;django.db.__init__.py&lt;/code&gt; 中，有以下代码片段:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Register an event to reset transaction state and close connections past
# their lifetime.
def close_old_connections(**kwargs):
    for conn in connections.all():
        conn.close_if_unusable_or_obsolete()
signals.request_started.connect(close_old_connections)
signals.request_finished.connect(close_old_connections)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，Django 将&lt;em&gt;请求开始&lt;/em&gt;/*请求结束*信号绑定给了 &lt;code&gt;close_old_connections&lt;/code&gt;函数，每当有请求开始和结束以后，Django 都会检查目前又没有失效的连接，如果有的话就将其关闭。通过这种办法，Django 保证处理请求时，数据库连接都是可用的，不会出现我遇到的问题；而我的程序在涉及 Model 操作时，没有检查连接的有效性，因而出现了题目中的错误。&lt;/p&gt;

&lt;h3 id=&#34;解决问题:85fe840e32cb336e68094805b95543ea&#34;&gt;解决问题&lt;/h3&gt;

&lt;p&gt;在定位到问题且知道处理方法后，接下来的工作就非常简单了。
仿照上述代码，定义函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from django import connection

def close_unusable_connection():
    if not connection.connection:
        return
    if connection.is_usable():
        return
    connection.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在每次 Model 操作前调用&lt;code&gt;close_unusable_connection()&lt;/code&gt;就解决问题了。当然，直接从&lt;code&gt;django.db&lt;/code&gt;中引入&lt;code&gt;close_old_connections&lt;/code&gt;然后调用应该也能解决问题，且支持多个连接的情况，请各位自行尝试。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在 MkDocs 中使用时序图及流程图</title>
      <link>http://zhaojames0707.github.io/post/mkdocs_diagram_support/</link>
      <pubDate>Tue, 21 Jun 2016 18:18:00 +0800</pubDate>
      
      <guid>http://zhaojames0707.github.io/post/mkdocs_diagram_support/</guid>
      <description>

&lt;p&gt;MkDocs 是非常方便的文档展示工具，但是原生不支持将 markdown 文档中的 sequence 及 flow 代码转换为时序图/流程图。
通过以下简单的3步，即可在不改变 markdown 文档的情况下，将时序图和流程图绘制出来。&lt;/p&gt;

&lt;h4 id=&#34;一-安装-pymdown-extensions:6da0e2d7c435d5f1a97cfa4adcf47a20&#34;&gt;一、安装 PyMdown Extensions:&lt;/h4&gt;

&lt;p&gt;PyMdown Extension 为 Python Markdown 提供了丰富的拓展，其中的 superfences 模块能支持 sequence/flow 图。
在终端执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install pymdown-extensions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后，在 MkDocs 项目的 mkdocs.yml 中添加：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;markdown_extensions:
    - pymdownx.superfences
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;二-引入-javascript-库:6da0e2d7c435d5f1a97cfa4adcf47a20&#34;&gt;二、引入 JavaScript 库&lt;/h4&gt;

&lt;p&gt;绘制流程图需要以下两个库：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bramp.github.io/js-sequence-diagrams/js/raphael-min.js&#34;&gt;raphael.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://flowchart.js.org/flowchart-latest.js&#34;&gt;flowchart.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;绘制时序图需要以下三个库：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bramp.github.io/js-sequence-diagrams/js/raphael-min.js&#34;&gt;raphael.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bramp.github.io/js-sequence-diagrams/js/underscore-min.js&#34;&gt;underscore.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bramp.github.io/js-sequence-diagrams/js/sequence-diagram-min.js&#34;&gt;sequence-diagram.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;引入方法很简单，添加到 mkdocs.yml 的 extra_javascript 属性即可，例子如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extra_javascript:
    - https://bramp.github.io/js-sequence-diagrams/js/raphael-min.js
    - https://bramp.github.io/js-sequence-diagrams/js/underscore-min.js
    - https://bramp.github.io/js-sequence-diagrams/js/sequence-diagram-min.js
    - http://flowchart.js.org/flowchart-latest.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以将 js 下载到本地，放到项目文件夹的 docs/js 文件夹下，引入例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extra_javascript:
	- js/raphael-min.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;三-引入三个-javascript-文件:6da0e2d7c435d5f1a97cfa4adcf47a20&#34;&gt;三、引入三个 JavaScript 文件&lt;/h4&gt;

&lt;p&gt;引入 js 库以后，还需要三个 js 文件。它们的作用是定位到目标 HTML 元素，调用对应的 JS 库，最终绘制成所需要的图。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;uml-converter.js&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function (win, doc) {
  win.convertUML = function(className, converter, settings) {
    var charts = doc.querySelectorAll(&amp;quot;pre.&amp;quot; + className),
        arr = [],
        i, j, maxItem, diagaram, text, curNode;

    // Is there a settings object?
    if (settings === void 0) {
        settings = {};
    }

    // Make sure we are dealing with an array
    for(i = 0, maxItem = charts.length; i &amp;lt; maxItem; i++) arr.push(charts[i])

    // Find the UML source element and get the text
    for (i = 0, maxItem = arr.length; i &amp;lt; maxItem; i++) {
        childEl = arr[i].firstChild;
        parentEl = childEl.parentNode;
        text = &amp;quot;&amp;quot;;
        for (j = 0; j &amp;lt; childEl.childNodes.length; j++) {
            curNode = childEl.childNodes[j];
            whitespace = /^\s*$/;
            if (curNode.nodeName === &amp;quot;#text&amp;quot; &amp;amp;&amp;amp; !(whitespace.test(curNode.nodeValue))) {
                text = curNode.nodeValue;
                break;
            }
        }

        // Do UML conversion and replace source
        el = doc.createElement(&#39;div&#39;);
        el.className = className;
        parentEl.parentNode.insertBefore(el, parentEl);
        parentEl.parentNode.removeChild(parentEl);
        diagram = converter.parse(text);
        diagram.drawSVG(el, settings);
    }
  }
})(window, document)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;flow-loader.js&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function (doc) {
  function onReady(fn) {
    if (doc.addEventListener) {
      doc.addEventListener(&#39;DOMContentLoaded&#39;, fn);
    } else {
      doc.attachEvent(&#39;onreadystatechange&#39;, function() {
        if (doc.readyState === &#39;interactive&#39;)
          fn();
      });
    }
  }

  onReady(function(){convertUML(&#39;uml-flowchart&#39;, flowchart);});
})(document)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;sequence-loader.js&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function (doc) {
  function onReady(fn) {
    if (doc.addEventListener) {
      doc.addEventListener(&#39;DOMContentLoaded&#39;, fn);
    } else {
      doc.attachEvent(&#39;onreadystatechange&#39;, function() {
        if (doc.readyState === &#39;interactive&#39;)
          fn();
      });
    }
  }

  onReady(function(){convertUML(&#39;uml-sequence-diagram&#39;, Diagram, {theme: &#39;simple&#39;});});
})(document)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将以上三个 js 保存至项目文件夹的 docs/js 文件夹内，并在 mkdocs.yml 中引入。引入方法同步骤二。
至此已经大功告成，此后使用 mkdocs serve 则能将 markdown 文档中的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```flow
xxx
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以及&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```sequence
xxx
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自动渲染成流程图和时序图。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>